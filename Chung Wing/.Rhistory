##arcGIS can't do this
#overlapping polygons can't be stored as multipart element - will cause problems
poly3.coords <- rbind(c(-66, 44), c(-64, 44), c(-66,47), c(-66, 44))
poly4.coords <- rbind(c(-67, 43), c(-64, 46), c(-66.5,46), c(-67, 43))
mpoly1.sfg  <- st_multipolygon( list(
list( poly1.outer.crd,  # Outer loop
poly1.inner.crd), # Inner loop
list( poly2.crd)) )     # Separate poly
mpoly2.sfg  <- st_multipolygon( list(
list(poly3.coords)))  # Unique polygon
mpoly3.sfg  <- st_multipolygon( list(
list(poly4.coords)) )  # Unique polygon
#generate simple feature object and assign coordinate system
mpoly.sfc <- st_sfc(list(mpoly1.sfg, mpoly2.sfg, mpoly3.sfg), crs = 4326)
mpoly.sf <- st_sf(mpoly.sfc)
#add attribute values and make transparent
mpoly.sf$ids <- c("A", "B", "C")
plot(mpoly.sf["ids"], axes = TRUE, main = NULL,
pal = sf.colors(alpha = 0.5, categorical = TRUE))
#make sure simple feature rules not violated
st_is_valid(mpoly.sf)
#### extract geometry from sf object ####
#create sfc from sf
st_geometry(mpoly.sf)
#extract coordinates from single record
st_geometry(mpoly.sf)[[1]]
#extract coordinate pairs from first element in list format
st_geometry(mpoly.sf)[[1]][]
#alternative syntax - bypass matrix creation by using WKT syntax
st_as_sfc("POLYGON ((-66 43, -70 47, -70 43, -66 43), (-68 44, -69 44, -69 45, -68 44))")
#### converting vector --> raster ####
#process is the same for points/polylines/polygons
library(tmap)
##nice pkg to visualise - can zoom in/out and move around in R
#recall data
tm_shape(elev.r) +
tm_raster(style = "fixed", title = "Elevasi (m)",
breaks = c(0, 100, 200, 400, 800, 1200, 1600),
palette = rev(heat.colors(6))) +
tm_shape(inter.sf)+ tm_lines(col="grey80", lwd = 0.7)+
tm_shape(rail.sf)+ tm_lines(col="grey20", lwd = 0.7)
##rasterization of rail.sf
#prepare raster template using elev data
raster_temp <- raster(elev.r)
##resolution and processing tradeoff
#assign all data into NA
raster_temp[] <- NA
#check values
summary(raster_temp)
#rasterise rail
rail.ras <- raster::rasterize(rail.sf, raster_temp, field = 1:nrow(rail.sf))
#plot
library(mapview)
mapview(rail.ras)
#### converting raster --> vector ####
rail.ras.sf <- raster::rasterToPolygons(rail.ras, dissolve = T)
mapview(rail.ras.sf)
#vectorise elevation
#first reclass the elev
elev.re <- raster::reclassify(elev.r, c(-Inf, 400, 1, 400, 800, 2, 800, 1200, 3, 1200, Inf, 4))
##changing into categorical bins rather than discrete values
#then vectorise it
elev.re.sf <- raster::rasterToPolygons(elev.re, dissolve = T)
mapview(elev.re.sf)
#loading spatial objects
library(sf)
z <- gzcon(url("https://github.com/mgimond/Spatial/raw/main/Data/Income_schooling_sf.rds"))
s1.sf <- readRDS(z)
z <- gzcon(url("https://github.com/mgimond/Spatial/raw/main/Data/Dist_sf.rds"))
s2.sf <- readRDS(z)
z <- gzcon(url("https://github.com/mgimond/Spatial/raw/main/Data/Highway_sf.rds"))
l1.sf <- readRDS(z)
#mapping layers using ggplot2
library(ggplot2)
ggplot() +
geom_sf(data = s1.sf) +
geom_sf(data = s2.sf, alpha = 0.5, col = "red") +
geom_sf(data = l1.sf, col = "blue")
#dissolve geometries that share boundaries
#can either (1) dissolve all polygons that share line segment for single outline
ME <- st_union(s1.sf, by_feature = FALSE)
ggplot(ME) + geom_sf(fill = "grey")
#can convert output (sfc) to sf object using st_sf(ME)
#option 2
library(dplyr)
ME <- s1.sf %>%
group_by() %>%
summarise()
ggplot(ME) + geom_sf(fill = "grey")
#dissolve by attribute
#create new column for whether income is higher/lower than median
s1.sf$med <- s1.sf$Income > median(s1.sf$Income)
#and plot based on variable
ggplot(s1.sf) + geom_sf(aes(fill = med))
#now dissolve based on attribute
#option 1 with sf aggregate function
ME.inc <- aggregate(s1.sf["med"], by = list(diss = s1.sf$med),
FUN = function(x)x[1], do_union = TRUE)
#by = defines new field
st_drop_geometry(ME.inc) # Print the layer's attributes table
#option 2 with dplyr approach
ME.inc <- s1.sf %>%
group_by(med) %>%
summarise() #limits attributes to those listed in group_by()
st_drop_geometry(ME.inc)
ggplot(ME.inc) + geom_sf(aes(fill = med)) #dissolving
#to summarize other attribute values (rather than eliminating)
ME.inc <- s1.sf %>%
group_by(med) %>%
summarize(medinc = median(Income))
ggplot(ME.inc) + geom_sf(aes(fill = medinc))
#view attributes table
st_drop_geometry(ME.inc)
#subset by attribute
ME.ken <- s1.sf[s1.sf$NAME == "Kennebec",] #subset by county name
ME.ken <- s1.sf %>%
filter(NAME == "Kennebec") #can also pipe
ggplot(ME.ken) + geom_sf()
#subset by range of attribute values
ME.inc2 <- s1.sf %>%
filter(Income < median(Income)) #subset of income less than median
ggplot(ME.inc2) + geom_sf()
#intersect two polygon objects
clp1 <- st_intersection(s1.sf, s2.sf)
ggplot(clp1) + geom_sf()
#creates new polygons so increases size of attribute table
st_drop_geometry(clp1)
#clip spatial objects using other spatial objects
##note: outer geometry must be limited to outer boundary (might need to dissolve first)
clp2 <- st_intersection(s2.sf, st_union(s1.sf))
ggplot(clp2) + geom_sf()
##note that the order of layers matters
clp2 <- st_intersection(s1.sf, st_union(s2.sf))
ggplot(clp2) + geom_sf()
#can also clip line segments to fit inside polygon
clp3 <- st_intersection(l1.sf, st_union(s2.sf))
#clip spatial objects using other spatial objects
##note: outer geometry must be limited to outer boundary (might need to dissolve first)
clp2 <- st_intersection(s2.sf, st_union(s1.sf)) #clip using outline of another
#intersect two polygon objects
clp1 <- st_intersection(s1.sf, s2.sf)
#subset by attribute
ME.ken <- s1.sf[s1.sf$NAME == "Kennebec",] #subset by county name
ME.ken <- s1.sf %>%
filter(NAME == "Kennebec") #can also pipe
ggplot(ME.ken) + geom_sf()
#subset by range of attribute values
ME.inc2 <- s1.sf %>%
filter(Income < median(Income)) #subset of income less than median
ggplot(ME.inc2) + geom_sf()
#intersect two polygon objects
clp1 <- st_intersection(s1.sf, s2.sf)
ggplot(clp1) + geom_sf()
#creates new polygons so increases size of attribute table
st_drop_geometry(clp1)
#clip spatial objects using other spatial objects
##note: outer geometry must be limited to outer boundary (might need to dissolve first)
clp2 <- st_intersection(s2.sf, st_union(s1.sf)) #clip using outline of another
ggplot(clp2) + geom_sf() #plot
##note that the order of layers matters
clp2 <- st_intersection(s1.sf, st_union(s2.sf)) #union() layer is the outline
ggplot(clp2) + geom_sf()
#can also clip line segments to fit inside polygon
clp3 <- st_intersection(l1.sf, st_union(s2.sf))
ggplot(clp3) +
geom_sf(data = clp3) +
geom_sf(data = st_union(s2.sf), col = "red", fill = NA )
#unioning two polygon objects
un1  <- st_union(s2.sf,s1.sf)
ggplot(un1) + geom_sf(aes(fill = NAME), alpha = 0.4)
##note: union generates overlapping geometries
##looking at example
un1 %>% filter(NAME == "Aroostook")
#buffering geometries (wider space around geometries?)
l1.sf.buf <- st_buffer(l1.sf, dist = 10000)
ggplot(l1.sf.buf) + geom_sf() + coord_sf(ndiscr = 1000)
#eliminate overlapping buffers for a continuous geometry
l1.sf.buf.dis <- l1.sf.buf %>%
group_by()  %>%
summarise()
ggplot(l1.sf.buf.dis) + geom_sf()
#preserve an attribute value
l1.sf.buf.dis <- l1.sf.buf %>%
group_by(Number)  %>%
summarise()
ggplot(l1.sf.buf.dis, aes(fill=Number) ) + geom_sf(alpha = 0.5)
#view attributes table
st_drop_geometry(ME.inc)
setwd("~/Documents/NTU/Spring 2022/ISS- Spatial Analysis in R/ISS_RSpatial/Chung Wing")
#remove unnecessary data objects from environment (not used here)
rm(list=c("inter.sf", "p.sf", "rail.sf"))
#load data
load(url("https://github.com/mgimond/Spatial/raw/main/Data/Sample1.RData"))
#remove unnecessary data objects from environment (not used here)
rm(list=c("inter.sf", "p.sf", "rail.sf"))
#load libraries
library(sf)
#check linked library versions
sf_extSoftVersion()[1:3]
#extract coordinate system info
st_crs(s.sf)
#extract CS info from raster with crs function
library(raster)
crs(elev.r)
#assigning a coordinate system (can fill empty definition or overwrite existing)\
s.sf <- st_set_crs(s.sf, "+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83") #assigning manually
st_crs(s.sf) #check object's CS
##note: some parameters now undefined
#so now define EPSG code
s.sf <- st_set_crs(s.sf, 26919)
st_crs(s.sf)
#defining CRS for raster
crs(elev.r) <- "+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83"
crs(elev.r) #checking it
#define CRS using EPSG code
crs(elev.r) <- "+init=EPSG:26919"
crs(elev.r)
#assigning a coordinate system (can fill empty definition or overwrite existing)\
s.sf <- st_set_crs(s.sf, "+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83") #assigning manually
st_crs(s.sf) #check object's CS
##note: some parameters now undefined
#so now define EPSG code
s.sf <- st_set_crs(s.sf, 26919)
st_crs(s.sf)
#defining CRS for raster
crs(elev.r) <- "+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83"
crs(elev.r) #checking it
#define CRS using EPSG code
crs(elev.r) <- "+init=EPSG:26919"
crs(elev.r)
#transform coordinate values to a diff coordinate system
##process calculates new coordinate pair values for all points defining spatial object
s.sf.gcs <- st_transform(s.sf, "+proj=longlat +datum=WGS84")
st_crs(s.sf.gcs)
#using EPSG code equivalent instead of proj4 string
s.sf.gcs <- st_transform(s.sf, 4326)
st_crs(s.sf.gcs)
#transform raster object
elev.r.gcs <- projectRaster(elev.r, crs="+proj=longlat +datum=WGS84")
crs(elev.r.gcs)
#transform raster using EPSG code
elev.r.gcs <- projectRaster(elev.r, crs="+init=EPSG:4326")
crs(elev.r.gcs)
#overlay transformation with OpenStreetMap to check transformation
library(leaflet)
leaflet(s.sf.gcs) %>%
addPolygons() %>%
addTiles()
#explore other transformations
library(tmap)
data(World)  #dataset is stored as an sf object
#check its current coordinate system
st_crs(World)
#transforms world map to custom azimuthal equidistant projection centered on 0,0
World.ae <- st_transform(World,
"+proj=aeqd +lat_0=0 +lon_0=0 +x_0=0 +y_0=0
+ellps=WGS84 +datum=WGS84 +units=m +no_defs")
st_crs(World.ae)
tm_shape(World.ae) + tm_fill()
#now centered on Maine
World.aemaine <- st_transform(World,
"+proj=aeqd +lat_0=44.5 +lon_0=-69.8
+x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
tm_shape(World.aemaine) + tm_fill()
#transforms to World Robinson projection
World.robin <- st_transform(World,
"+proj=robin +lon_0=0 +x_0=0 +y_0=0
+ellps=WGS84 +datum=WGS84 +units=m +no_defs")
tm_shape(World.robin) + tm_fill()
#transform to World sinusoidal projection
World.sin <- st_transform(World,
"+proj=sinu +lon_0=0 +x_0=0 +y_0=0
+ellps=WGS84 +datum=WGS84 +units=m +no_defs")
tm_shape(World.sin) + tm_fill()
World.mercator <- st_transform(World,
"+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0
+ellps=WGS84 +datum=WGS84 +units=m +no_defs")
tm_shape(World.mercator) + tm_fill()
#example of a failed transformation
##note: issue when polygon features are split across 180 deg meridian
World.mercator2 <- st_transform(World,
"+proj=merc +lon_0=-69 +k=1 +x_0=0
+y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
tm_shape(World.mercator2) + tm_borders()
##polygons are split and R doesn't know how to piece them together
#can fix with maptools - requires object be of "Spatial" type and geographic reference system
library(maptools)
#convert to lat/long reference system
wld.ll <- st_transform(World, "+proj=longlat +datum=WGS84 +no_defs")
#convert to lat/long reference system
wld.ll <- st_transform(World, "+proj=longlat +datum=WGS84 +no_defs")
#convert to a spatial object, then split the polygons at a given longitude (111 in this example)
wld.sp <- nowrapSpatialPolygons(as(wld.ll, "Spatial"), offset = 111)
#convert back to an sf object, reproject to a new longitude center at -69 degrees
#then plot it
wld.sf <- st_as_sf(wld.sp)
install.packages(rgeos)
install.packages("rgeos")
library(rgeos)
#convert back to an sf object, reproject to a new longitude center at -69 degrees
#then plot it
wld.sf <- st_as_sf(wld.sp)
wld.merc2.sf <- st_transform(wld.sf, "+proj=merc +lon_0=-69 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
#convert to lat/long reference system
wld.ll <- st_transform(World, "+proj=longlat +datum=WGS84 +no_defs")
#convert to a spatial object, then split the polygons at a given longitude (111 in this example)
wld.sp <- nowrapSpatialPolygons(as(wld.ll, "Spatial"), offset = 111)
#convert back to an sf object, reproject to a new longitude center at -69 degrees
#then plot it
wld.sf <- st_as_sf(wld.sp)
wld.merc2.sf <- st_transform(wld.sf, "+proj=merc +lon_0=-69 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
tm_shape(wld.merc2.sf) + tm_borders()
wld.rob.sf <- st_transform(wld.sf,
"+proj=robin +lon_0=-69 +x_0=0 +y_0=0
+ellps=WGS84 +datum=WGS84 +units=m +no_defs")
#missing values --zoom in using unprojected layers and overlap map with centroids
library(dplyr)
#extract the extent for the Norwar/Sweden region
nor.bb <- World %>% filter(name == "Norway" | name == "Sweden") %>% st_bbox()
#plot the data zoomed in on the region. Add the point layer for reference
tm_shape(World, bbox=nor.bb) + tm_polygons(col="pop_est_dens", style="quantile") +
tm_shape(pt) + tm_dots() +
tm_text("name", just="left", xmod=0.5, size=0.8) +
tm_legend(outside=TRUE)
##note: transformations affect points, not line segments - so points enclosed may sometimes fall outside polygon when projection changes
#define a few projections
miller <- "+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
lambert <- "+proj=lcc +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
#subset the World data layer
wld.mil <-  World %>% filter( iso_a3  == "CAN" |  iso_a3 == "USA") %>% st_transform( miller)
#create polygon and point layers in the Miller projection
sf1 <- st_sfc( st_polygon(list(cbind(c(-13340256,-13340256,-6661069, -6661069, -13340256),
c(7713751, 5326023, 5326023,7713751, 7713751 )))), crs = miller)
pt1 <- st_sfc( st_multipoint(rbind(c(-11688500,7633570), c(-11688500,5375780),
c(-10018800,7633570), c(-10018800,5375780),
c(-8348960,7633570), c(-8348960,5375780))),  crs = miller)
pt1 <- st_cast(pt1, "POINT") # Create single part points
#plot the data layers in their native projection
tm_shape(wld.mil) +tm_fill(col="grey") +
tm_graticules(x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey90") +
tm_shape(sf1) + tm_polygons("red", alpha = 0.5, border.col = "yellow") +
tm_shape(pt1) + tm_dots(size=0.2)
#confirm that points are contained inside polygon
st_contains(sf1, pt1)
#reproject data into Lambert conformal projection
#transform the data
wld.lam <- st_transform(wld.mil, lambert)
pt1.lam <- st_transform(pt1, lambert)
sf1.lam <- st_transform(sf1, lambert)
sf1.lam <- st_transform(sf1, lambert)
#plot the data in the Lambert coordinate system
tm_shape(wld.lam) +tm_fill(col="grey") +
tm_graticules( x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey90") +
tm_shape(sf1.lam) + tm_polygons("red", alpha = 0.5, border.col = "yellow") +
tm_shape(pt1.lam) + tm_dots(size=0.2)
#check if points contained
st_contains(sf1.lam, pt1.lam)
#to resolve, densify polygon by adding vertices (based on resolution needed)
#add vertices every 1000 meters along the polygon's line segments
sf2 <- st_segmentize(sf1, 1000)
#to resolve, densify polygon by adding vertices (based on resolution needed)
#add vertices every 1000 meters along the polygon's line segments
sf2 <- st_segmentize(sf1, 1000)
#transform the newly densified polygon layer
sf2.lam <- st_transform(sf2, lambert)
#transform the newly densified polygon layer
sf2.lam <- st_transform(sf2, lambert)
#plot the data
tm_shape(wld.lam) + tm_fill(col="grey") +
tm_graticules( x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey90") +
tm_shape(sf2.lam) + tm_polygons("red", alpha = 0.5, border.col = "yellow") +
tm_shape(pt1.lam) + tm_dots(size=0.2)
#check contains
st_contains(sf2.lam, pt1.lam)
#projections create distortions of area and shape
#visualise distortions by creating geodesic circles
tissot.pt <- st_sfc( st_multipoint(rbind(c(-60,30), c(-60,45), c(-60,60),
c(-80,30), c(-80,45), c(-80,60),
c(-100,30), c(-100,45), c(-100,60),
c(-120,30), c(-120,45), c(-120,60) )),  crs = "+proj=longlat")
tissot.pt <- st_cast(tissot.pt, "POINT") # Create single part points
#create geodesic circles from these points
library(geosphere)
cr.pt <- list() #create an empty list
#loop through each point in tissot.pt and generate 360 vertices at 300 km
#from each point in all directions at 1 degree increment. These vertices
#will be used to approximate the Tissot circles
for (i in 1:length(tissot.pt)){
cr.pt[[i]] <- list( destPoint( as(tissot.pt[i], "Spatial"), b=seq(0,360,1), d=300000) )
}
#create a closed polygon from the previously generated vertices
tissot.sfc <- st_cast( st_sfc(st_multipolygon(cr.pt ),crs = "+proj=longlat"), "POLYGON" )
#check these are geodesic circles by computing geodesic area of each polygon
tissot.sf <- st_sf( geoArea =  st_area(tissot.sfc), tissot.sfc )
#compute error in output and report as fractions
( (pi * 300000^2) -  as.vector(tissot.sf$geoArea) ) / (pi * 300000^2)
##note: transformations affect points, not line segments - so points enclosed may sometimes fall outside polygon when projection changes
#define a few projections
miller <- "+proj=mill +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
lambert <- "+proj=lcc +lat_1=20 +lat_2=60 +lat_0=40 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
#subset the World data layer
wld.mil <-  World %>% filter( iso_a3  == "CAN" |  iso_a3 == "USA") %>% st_transform( miller)
#create polygon and point layers in the Miller projection
sf1 <- st_sfc( st_polygon(list(cbind(c(-13340256,-13340256,-6661069, -6661069, -13340256),
c(7713751, 5326023, 5326023,7713751, 7713751 )))), crs = miller)
/pt1 <- st_sfc( st_multipoint(rbind(c(-11688500,7633570), c(-11688500,5375780),
c(-10018800,7633570), c(-10018800,5375780),
c(-8348960,7633570), c(-8348960,5375780))),  crs = miller)
pt1 <- st_sfc( st_multipoint(rbind(c(-11688500,7633570), c(-11688500,5375780),
c(-10018800,7633570), c(-10018800,5375780),
c(-8348960,7633570), c(-8348960,5375780))),  crs = miller)
pt1 <- st_cast(pt1, "POINT") #create single part points
#plot the data layers in their native projection
tm_shape(wld.mil) +tm_fill(col="grey") +
tm_graticules(x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey90") +
tm_shape(sf1) + tm_polygons("red", alpha = 0.5, border.col = "yellow") +
tm_shape(pt1) + tm_dots(size=0.2)
#confirm that points are contained inside polygon
st_contains(sf1, pt1)
#reproject data into Lambert conformal projection
#transform the data
wld.lam <- st_transform(wld.mil, lambert)
pt1.lam <- st_transform(pt1, lambert)
sf1.lam <- st_transform(sf1, lambert)
#plot the data in the Lambert coordinate system
tm_shape(wld.lam) +tm_fill(col="grey") +
tm_graticules( x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey90") +
tm_shape(sf1.lam) + tm_polygons("red", alpha = 0.5, border.col = "yellow") +
tm_shape(pt1.lam) + tm_dots(size=0.2)
#check if points contained
st_contains(sf1.lam, pt1.lam) #only 3/6 points contained
#to resolve, densify polygon by adding vertices (based on resolution needed)
#add vertices every 1000 meters along the polygon's line segments
sf2 <- st_segmentize(sf1, 1000)
#transform the newly densified polygon layer
sf2.lam <- st_transform(sf2, lambert)
#plot the data
tm_shape(wld.lam) + tm_fill(col="grey") +
tm_graticules( x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey90") +
tm_shape(sf2.lam) + tm_polygons("red", alpha = 0.5, border.col = "yellow") +
tm_shape(pt1.lam) + tm_dots(size=0.2)
#check contains
st_contains(sf2.lam, pt1.lam)
#projections create distortions of area and shape
#visualise distortions by creating geodesic circles
#create point layer to define circle centers
tissot.pt <- st_sfc( st_multipoint(rbind(c(-60,30), c(-60,45), c(-60,60),
c(-80,30), c(-80,45), c(-80,60),
c(-100,30), c(-100,45), c(-100,60),
c(-120,30), c(-120,45), c(-120,60) )),  crs = "+proj=longlat")
tissot.pt <- st_cast(tissot.pt, "POINT") #create single part points
#create geodesic circles from these points
library(geosphere)
cr.pt <- list() #create an empty list
#loop through each point in tissot.pt and generate 360 vertices at 300 km
#from each point in all directions at 1 degree increment. These vertices
#will be used to approximate the Tissot circles
for (i in 1:length(tissot.pt)){
cr.pt[[i]] <- list( destPoint( as(tissot.pt[i], "Spatial"), b=seq(0,360,1), d=300000) )
}
#create a closed polygon from the previously generated vertices
tissot.sfc <- st_cast( st_sfc(st_multipolygon(cr.pt ),crs = "+proj=longlat"), "POLYGON" )
#check these are geodesic circles by computing geodesic area of each polygon
tissot.sf <- st_sf( geoArea =  st_area(tissot.sfc), tissot.sfc )
#compute error in output and report as fractions
( (pi * 300000^2) -  as.vector(tissot.sf$geoArea) ) / (pi * 300000^2)
#distortions associated with popular CS
#mercator projection
#transform geodesic circles and compute area error as a percentage
tissot.merc <- st_transform(tissot.sf, "+proj=merc +ellps=WGS84")
tissot.merc$area_err <- round((st_area(tissot.merc, tissot.merc$geoArea)) /
tissot.merc$geoArea * 100 , 2)
#plot the map
tm_shape(World, bbox = st_bbox(tissot.merc), projection = st_crs(tissot.merc)) +
tm_borders() +
tm_shape(tissot.merc) + tm_polygons(col="grey", border.col = "red", alpha = 0.3) +
tm_graticules(x = c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey80") +
tm_text("area_err", size=.8, alpha=0.8, col="blue")
#Lambert azimuthal equal area projection
#transform geodesic circles and compute area error as a percentage
tissot.laea <- st_transform(tissot.sf, "+proj=laea +lat_0=45 +lon_0=-100 +ellps=WGS84")
tissot.laea$area_err <- round( (st_area(tissot.laea ) - tissot.laea$geoArea) /
tissot.laea$geoArea * 100, 2)
#plot the map
tm_shape(World, bbox = st_bbox(tissot.laea), projection = st_crs(tissot.laea)) +
tm_borders() +
tm_shape(tissot.laea) + tm_polygons(col="grey", border.col = "red", alpha = 0.3) +
tm_graticules(x=c(-60,-80,-100, -120, -140),
y = c(30,45, 60),
labels.col = "white", col="grey80") +
tm_text("area_err", size=.8, alpha=0.8, col="blue")
setwd("~/Documents/NTU/Spring 2022/ISS- Spatial Analysis in R/ISS_RSpatial/Chung Wing")
# Load spatial data
library(rgdal)
mydata <- readOGR("Income_schooling.shp")
# Load spatial data
library(rgdal)
mydata <- readOGR("Income_schooling.shp")
